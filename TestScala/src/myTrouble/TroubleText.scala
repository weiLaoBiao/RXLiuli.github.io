package myTrouble

/**
  * Created by RXLiuli on 2017/4/23.
  */
object TroubleText {

    //region Scala中没有引用传递么?

    //endregion

    //region 全栈/专家
    /**
      * 全栈优于专家
      */
    //endregion

    //region 什么时候使用协变和逆变?
    //endregion

    //region 什么时候要用柯里化(多参数列表)? 现在还有Curry化?
    //endregion

    //region 什么时候使用中缀写法?
    /**
      * 仅当调用类似于操作符的方法时才使用中缀写法
      */
    //endregion

    //region 什么时候使用尾递归和迭代
    /**
      * 一般情况使用迭代,使用尾递归实现相当易懂的时候使用尾递归
      * 无法使用迭代实现的时候使用递归
      */
    //endregion

    //region Scala到底是做什么的?
    /**
      * 大数据
      */
    //endregion

    //region 正则表达式模式匹配已废弃?!

    //endregion

    //region 集合库到底要怎么用?

    //region


    //endregion

    //endregion

    //region 序列之争
    /**
      * vector与list区别
      * vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vecotor中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。
      * list中的对象是离散存储的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。
      * 综上所述：
      * vector适用：对象数量变化少，简单对象，随机访问元素频繁
      * list适用：对象数量变化大，对象复杂，插入和删除频繁
      * 最大的区别是,list是双向的，而vector是单向的。
      * 因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面
      * 的原则：
      * 1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
      * 2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list
      * 3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。
      * vector
      * 表示一段连续的内存区域，每个元素被顺序存储在这段内存中，对vector   的随机访问效率很高，但对非末尾元素的插入和删除则效率非常低。
      * deque
      * 也表示一段连续的内存区域，但与vector不同的是它支持高效地在其首部插入和删除元素，它通过两级数组结构来实现，一级表示实际的容器，第二级指向容器的首和尾
      * list
      * 表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来，插入删除效率高，随机访问效率低
      * 2，stl提供了三个最基本的容器：vector,list,deque。
      * vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此
      * 它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间
      * 进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新
      * 申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。
      * list就是数据结构中的双向链表(根据sgi
      * stl源代码)，因此它的内存空间可以是不连续
      * 的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它
      * 没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除
      * 和插入。
      * deque是一个double-ended   queue，它的具体实现不太清楚，但知道它具有以下两个特点：
      * 它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的
      * 操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上与list的效率
      * 也差不多。
      * 因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面
      * 的原则：
      * 1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
      * 2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list
      * 3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。
      */
    //endregion

}
